name: SyncScribe VM Control

# SETUP INSTRUCTIONS:
# 1. Add GitHub Repository Variables (Settings > Secrets and variables > Actions > Variables):
#    - VM_NAME: syncscribe-vm (optional, has default)
#    - VM_ZONE: us-central1-a (optional, has default)
#    - REACT_APP_SERVER_URL: https://syncscribe.app (optional, has default)
#    - GCS_BUCKET_N1: syncscribe-n1 (REQUIRED - update from old GCS_NG_BUCKET)
#    - GCS_BUCKET_U1: syncscribe-u1 (REQUIRED - update from old GCS_UKG_BUCKET)
#
# 2. Add GitHub Repository Secrets (Settings > Secrets and variables > Actions > Secrets):
#    - OPENAI_API_KEY: Your OpenAI API key
#    - DEEPGRAM_API_KEY: Your Deepgram API key
#    - ASSEMBLYAI_API_KEY: Your AssemblyAI API key
#    - OPENROUTER_API_KEY: Your OpenRouter API key
#    - GCS_CLIENT_EMAIL: GCS service account email
#    - GCS_PRIVATE_KEY: GCS service account private key
#    - GCP_WIF_PROVIDER: Workload Identity Federation provider
#    - GCP_WIF_SERVICE_ACCOUNT: Service account email for WIF
#    - REACT_APP_RAG_PASSWORD: Optional RAG password (leave empty for production)
#
# 3. Grant service account permissions (GCP_WIF_SERVICE_ACCOUNT secret):
#    gcloud projects add-iam-policy-binding meeting-trans-443019 \
#      --member="serviceAccount:SERVICE_ACCOUNT_EMAIL" \
#      --role="roles/compute.instanceAdmin.v1"
#
# 4. Required permissions:
#    - compute.instances.get
#    - compute.instances.start
#    - compute.instances.stop
#    - compute.instances.use (for SSH)

on:
  workflow_dispatch:
    inputs:
      action:
        description: "VM deployment action"
        required: true
        type: choice
        options:
          - deploy-offline
          - deploy-online
        default: deploy-online

permissions:
  contents: read
  id-token: write

env:
  # Set via GitHub Repository Variables
  GCP_PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  VM_NAME: ${{ vars.VM_NAME || 'syncscribe-vm' }}
  VM_ZONE: ${{ vars.VM_ZONE || 'us-central1-a' }}
  USE_GKE_GCLOUD_AUTH_PLUGIN: "True"
  # VM's service account (default compute service account)
  VM_SERVICE_ACCOUNT: "840029787447-compute@developer.gserviceaccount.com"

jobs:
  vm-control:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Authenticate to Google Cloud via Workload Identity Federation
      - name: Authenticate to Google Cloud (WIF)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_WIF_SERVICE_ACCOUNT }}
          access_token_lifetime: 3600s
          access_token_scopes: https://www.googleapis.com/auth/cloud-platform

      - name: Setup gcloud CLI
        uses: google-github-actions/setup-gcloud@v2

      - name: Verify VM access and permissions
        run: |
          echo "Verifying VM access and permissions..."
          if gcloud compute instances describe "$VM_NAME" \
            --zone="$VM_ZONE" \
            --project="$GCP_PROJECT_ID" \
            --format="get(status,networkInterfaces[0].accessConfigs[0].natIP)" 2>&1; then
            echo "[OK] VM access verified"
          else
            echo "[X] Error: Service account lacks required permissions"
            echo ""
            echo "Required permissions:"
            echo "  - compute.instances.get"
            echo "  - compute.instances.start"
            echo "  - compute.instances.stop"
            echo "  - compute.instances.use (for SSH)"
            echo ""
            echo "Grant these permissions to the service account:"
            echo "  ${{ secrets.GCP_WIF_SERVICE_ACCOUNT }}"
            echo ""
            echo "Or assign the 'Compute Instance Admin' role:"
            echo "  gcloud projects add-iam-policy-binding $GCP_PROJECT_ID \\"
            echo "    --member='serviceAccount:${{ secrets.GCP_WIF_SERVICE_ACCOUNT }}' \\"
            echo "    --role='roles/compute.instanceAdmin.v1'"
            exit 1
          fi

      - name: Make scripts executable
        run: |
          chmod +x scripts/deploy-offline.sh
          chmod +x scripts/deploy-online.sh

      - name: Run deploy-offline
        if: inputs.action == 'deploy-offline'
        env:
          VM_NAME: ${{ env.VM_NAME }}
          ZONE: ${{ env.VM_ZONE }}
          STOP_VM: "true"
        run: |
          echo "Running deploy-offline.sh..."
          export VM_NAME="$VM_NAME"
          export ZONE="$ZONE"
          export STOP_VM="$STOP_VM"
          # Impersonate VM's service account for SSH access
          export CLOUDSDK_AUTH_IMPERSONATE_SERVICE_ACCOUNT="${{ env.VM_SERVICE_ACCOUNT }}"
          ./scripts/deploy-offline.sh

      - name: Run deploy-online
        if: inputs.action == 'deploy-online'
        env:
          VM_NAME: ${{ env.VM_NAME }}
          ZONE: ${{ env.VM_ZONE }}
          # Use the branch that triggered this workflow (from "Use workflow from" dropdown)
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_WORKSPACE: ${{ github.workspace }}
          GITHUB_REF: ${{ github.ref }}  # This will be the selected branch (e.g., refs/heads/your-branch)
          DEPLOY_CODE: "true"
          # API Keys from GitHub Secrets (will be injected into .env file on VM)
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          DEEPGRAM_API_KEY: ${{ secrets.DEEPGRAM_API_KEY }}
          ASSEMBLYAI_API_KEY: ${{ secrets.ASSEMBLYAI_API_KEY }}
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          # GCS Credentials from Secrets
          GCS_CLIENT_EMAIL: ${{ secrets.GCS_CLIENT_EMAIL }}
          GCS_PRIVATE_KEY: ${{ secrets.GCS_PRIVATE_KEY }}
          # GCS Configuration (set in GitHub Repository Variables)
          # NOTE: Update GitHub Variables to use GCS_BUCKET_N1 and GCS_BUCKET_U1 (not GCS_NG_BUCKET/GCS_UKG_BUCKET)
          GCS_PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
          GCS_BUCKET_N1: ${{ vars.GCS_BUCKET_N1 }}
          GCS_BUCKET_U1: ${{ vars.GCS_BUCKET_U1 }}
          REACT_APP_SERVER_URL: ${{ vars.REACT_APP_SERVER_URL || 'https://syncscribe.app' }}
          # Optional: Set RAG password for specific environments via secrets
          REACT_APP_RAG_PASSWORD: ${{ secrets.REACT_APP_RAG_PASSWORD }}
        run: |
          echo "Running deploy-online.sh..."
          echo "Deploying from branch: ${{ github.ref }}"
          export VM_NAME="$VM_NAME"
          export ZONE="$ZONE"
          export GITHUB_REPOSITORY="$GITHUB_REPOSITORY"
          export GITHUB_WORKSPACE="$GITHUB_WORKSPACE"
          export GITHUB_REF="$GITHUB_REF"
          export DEPLOY_CODE="$DEPLOY_CODE"
          # Export API keys for .env file creation
          export OPENAI_API_KEY="$OPENAI_API_KEY"
          export DEEPGRAM_API_KEY="$DEEPGRAM_API_KEY"
          export ASSEMBLYAI_API_KEY="$ASSEMBLYAI_API_KEY"
          export OPENROUTER_API_KEY="$OPENROUTER_API_KEY"
          export GCS_CLIENT_EMAIL="$GCS_CLIENT_EMAIL"
          export GCS_PRIVATE_KEY="$GCS_PRIVATE_KEY"
          export GCS_PROJECT_ID="$GCS_PROJECT_ID"
          export GCS_BUCKET_N1="$GCS_BUCKET_N1"
          export GCS_BUCKET_U1="$GCS_BUCKET_U1"
          export REACT_APP_SERVER_URL="$REACT_APP_SERVER_URL"
          export REACT_APP_RAG_PASSWORD="$REACT_APP_RAG_PASSWORD"
          # Impersonate VM's service account for SSH access
          export CLOUDSDK_AUTH_IMPERSONATE_SERVICE_ACCOUNT="${{ env.VM_SERVICE_ACCOUNT }}"
          ./scripts/deploy-online.sh

      - name: Show VM status
        if: always()
        run: |
          echo "=== VM Status ==="
          gcloud compute instances describe "$VM_NAME" \
            --zone="$VM_ZONE" \
            --project="$GCP_PROJECT_ID" \
            --format="table(
              name,
              status,
              networkInterfaces[0].accessConfigs[0].natIP:label=EXTERNAL_IP,
              machineType.scope(machineTypes):label=MACHINE_TYPE
            )" || echo "VM not accessible"

      - name: Show container status
        if: always() && inputs.action == 'deploy-online'
        env:
          CLOUDSDK_AUTH_IMPERSONATE_SERVICE_ACCOUNT: ${{ env.VM_SERVICE_ACCOUNT }}
        run: |
          echo "=== Container Status ==="
          SSH_OPTS="--zone=$VM_ZONE --quiet"
          if [ -n "$CLOUDSDK_AUTH_IMPERSONATE_SERVICE_ACCOUNT" ]; then
            SSH_OPTS="$SSH_OPTS --impersonate-service-account=$CLOUDSDK_AUTH_IMPERSONATE_SERVICE_ACCOUNT"
          fi
          if gcloud compute ssh "$VM_NAME" $SSH_OPTS \
            --project="$GCP_PROJECT_ID" \
            --command="cd ~/meeting-transcriber && sudo docker-compose ps 2>&1" 2>&1; then
            echo "[OK] Container status retrieved"
          else
            echo "[X] Could not check container status"
            echo "  This may be due to:"
            echo "  - VM is still starting up"
            echo "  - SSH connection issues"
            echo "  - Missing iam.serviceAccountUser permission"
          fi

      - name: Show DNS status
        if: always() && inputs.action == 'deploy-online'
        run: |
          echo "=== DNS Status ==="
          VM_IP=$(gcloud compute instances describe "$VM_NAME" \
            --zone="$VM_ZONE" \
            --project="$GCP_PROJECT_ID" \
            --format='get(networkInterfaces[0].accessConfigs[0].natIP)' 2>/dev/null || echo "")
          
          if [ -n "$VM_IP" ]; then
            echo "VM IP: $VM_IP"
            DNS_IP=$(dig +short syncscribe.app 2>/dev/null | head -1 || echo "")
            if [ -n "$DNS_IP" ]; then
              if [ "$VM_IP" = "$DNS_IP" ]; then
                echo "DNS: $DNS_IP (matches VM IP)"
              else
                echo "DNS: $DNS_IP (mismatch - update DNS to $VM_IP)"
              fi
            else
              echo "DNS: Could not resolve syncscribe.app"
            fi
          else
            echo "Could not determine VM IP"
          fi

